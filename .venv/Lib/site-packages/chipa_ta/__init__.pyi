# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import typing

class Candle:
    r"""
    Python wrapper for a candlestick/bar data structure
    """
    price: builtins.float
    high: builtins.float
    low: builtins.float
    open: builtins.float
    close: builtins.float
    volume: builtins.float
    def __new__(cls, price:builtins.float, high:builtins.float, low:builtins.float, open:builtins.float, close:builtins.float, volume:builtins.float) -> Candle:
        r"""
        Create a new Candle with explicit OHLCV data.
        
        Args:
            price: Typical or reference price for the candle
            high: Highest price during the period
            low: Lowest price during the period
            open: Opening price
            close: Closing price
            volume: Trading volume
        
        Returns:
            Candle: A new Candle instance
        
        Example:
            >>> candle = Candle.new(100.5, 101.0, 99.0, 100.0, 100.5, 1000.0)
        """
    @staticmethod
    def price(price:builtins.float) -> Candle:
        r"""
        Create a Candle from a single price value.
        
        Sets all OHLC fields to the same price with zero volume.
        Useful for simple price-based indicators that don't need full candle data.
        
        Args:
            price: Price value to use for all OHLC fields
        
        Returns:
            Candle: A new Candle instance with all prices set to the input value
        
        Example:
            >>> candle = Candle.price(100.5)
            >>> # candle.open == candle.high == candle.low == candle.close == 100.5
        """
    @staticmethod
    def from_json(json:builtins.str) -> Candle:
        r"""
        Deserialize a Candle from a JSON string.
        
        It has built-in support for the candles passed to the `BinaryOptionToolsV2.PyStrategy.on_candle` function.
        
        The JSON must contain: open, high, low, close, volume.
        The 'price' field is automatically calculated from 'close'.
        Extra fields (like timestamp) are accepted and stored internally but not accessible.
        
        Args:
            json: JSON string with candle data
        
        Returns:
            Candle: A new Candle instance
        
        Raises:
            ValueError: If JSON is invalid or missing required fields
        
        Example:
            >>> json_str = '{"open": 100.0, "high": 101.0, "low": 99.0, "close": 100.5, "volume": 1000.0, "timestamp": 1234567890}'
            >>> candle = Candle.from_json(json_str)
            >>> # candle.price will be 100.5 (same as close)
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class Indicator:
    r"""
    Python wrapper for technical analysis indicators
    """
    def __new__(cls) -> Indicator:
        r"""
        Create a new None indicator (pass-through that returns input unchanged).
        
        Returns:
            Indicator: A None indicator instance
        """
    @staticmethod
    def from_string(json:builtins.str) -> Indicator:
        r"""
        Deserialize an indicator from a JSON string.
        
        Args:
            json: JSON string representation of the indicator
        
        Returns:
            Indicator: Deserialized indicator instance
        
        Raises:
            ValueError: If the JSON is invalid or doesn't match indicator format
        
        Example:
            >>> json_str = '{"type":"Rsi","period":14}'
            >>> indicator = Indicator.from_string(json_str)
        """
    @staticmethod
    def ema(period:builtins.int) -> Indicator:
        r"""
        Create an Exponential Moving Average (EMA) indicator.
        
        EMA gives more weight to recent prices using exponential smoothing.
        
        Math:
            EMA_t = Price_t × α + EMA_(t-1) × (1 - α)
            where α = 2 / (period + 1)
        
        Args:
            period: Number of periods for the EMA calculation
        
        Returns:
            Indicator: EMA indicator instance
        
        Raises:
            ValueError: If period is invalid (must be > 0)
        """
    @staticmethod
    def sma(period:builtins.int) -> Indicator:
        r"""
        Create a Simple Moving Average (SMA) indicator.
        
        SMA calculates the arithmetic mean of prices over a specified period.
        
        Math:
            SMA = (P_1 + P_2 + ... + P_n) / n
            where P_i is the price at period i, n is the period
        
        Args:
            period: Number of periods for the SMA calculation
        
        Returns:
            Indicator: SMA indicator instance
        
        Raises:
            ValueError: If period is invalid (must be > 0)
        """
    @staticmethod
    def rsi(period:builtins.int) -> Indicator:
        r"""
        Create a Relative Strength Index (RSI) indicator.
        
        RSI oscillates between 0-100, measuring momentum and overbought/oversold conditions.
        
        Math:
            RS = Average Gain / Average Loss (over n periods)
            RSI = 100 - (100 / (1 + RS))
            Overbought: RSI > 70, Oversold: RSI < 30
        
        Args:
            period: Number of periods for RSI calculation (commonly 14)
        
        Returns:
            Indicator: RSI indicator instance
        
        Raises:
            ValueError: If period is invalid (must be > 0)
        """
    @staticmethod
    def macd(fast_period:builtins.int, slow_period:builtins.int, signal_period:builtins.int) -> Indicator:
        r"""
        Create a Moving Average Convergence Divergence (MACD) indicator.
        
        MACD shows the relationship between two EMAs, useful for trend and momentum analysis.
        
        Math:
            MACD Line = EMA_fast - EMA_slow
            Signal Line = EMA(MACD Line, signal_period)
            Histogram = MACD Line - Signal Line
        
        Args:
            fast_period: Period for the fast EMA (commonly 12)
            slow_period: Period for the slow EMA (commonly 26)
            signal_period: Period for the signal line EMA (commonly 9)
        
        Returns:
            Indicator: MACD indicator instance (returns [MACD line, Signal line, Histogram])
        
        Raises:
            ValueError: If periods are invalid or fast >= slow
        """
    @staticmethod
    def tr() -> Indicator:
        r"""
        Create a True Range (TR) indicator.
        
        TR measures single-period volatility, used as a component of ATR.
        
        Math:
            TR = max(High - Low, |High - Close_prev|, |Low - Close_prev|)
        
        Returns:
            Indicator: True Range indicator instance
        
        Note:
            Requires candle input (High, Low, Close)
        """
    @staticmethod
    def atr(period:builtins.int) -> Indicator:
        r"""
        Create an Average True Range (ATR) indicator.
        
        ATR measures market volatility by averaging the True Range over a period.
        
        Math:
            ATR_t = (ATR_(t-1) × (n-1) + TR_t) / n
            where TR is True Range, n is period
        
        Args:
            period: Number of periods for ATR calculation (commonly 14)
        
        Returns:
            Indicator: ATR indicator instance
        
        Raises:
            ValueError: If period is invalid (must be > 0)
        
        Note:
            Requires candle input (High, Low, Close)
        """
    @staticmethod
    def super_trend(multiplier:builtins.float, period:builtins.int) -> Indicator:
        r"""
        Create a SuperTrend indicator.
        
        SuperTrend provides dynamic support/resistance levels based on ATR.
        
        Math:
            Basic Band = (High + Low) / 2
            Upper Band = Basic Band + (multiplier × ATR)
            Lower Band = Basic Band - (multiplier × ATR)
            SuperTrend switches between upper/lower based on trend direction
        
        Args:
            multiplier: ATR multiplier for band calculation (commonly 3.0)
            period: Period for ATR calculation (commonly 10)
        
        Returns:
            Indicator: SuperTrend indicator instance
        
        Raises:
            ValueError: If parameters are invalid
        
        Note:
            Requires candle input (High, Low, Close)
        """
    @staticmethod
    def bb(period:builtins.int, k:builtins.float) -> Indicator:
        r"""
        Create a Bollinger Bands (BB) indicator.
        
        BB consists of a middle band (SMA) and upper/lower bands based on standard deviation.
        
        Math:
            Middle Band = SMA(price, period)
            Upper Band = Middle Band + (k × σ)
            Lower Band = Middle Band - (k × σ)
            where σ is standard deviation of price over period
        
        Args:
            period: Period for SMA and standard deviation (commonly 20)
            k: Number of standard deviations for bands (commonly 2.0)
        
        Returns:
            Indicator: Bollinger Bands indicator (returns [Middle, Upper, Lower])
        
        Raises:
            ValueError: If parameters are invalid
        """
    @staticmethod
    def stoch(period:builtins.int, smoothing_period:builtins.int) -> Indicator:
        r"""
        Create a Stochastic Oscillator indicator.
        
        Stochastic compares closing price to price range, showing momentum.
        
        Math:
            %K = ((Close - Lowest Low) / (Highest High - Lowest Low)) × 100
            %D = SMA(%K, smoothing_period)
            where High/Low are over the lookback period
        
        Args:
            period: Lookback period for %K calculation (commonly 14)
            smoothing_period: Smoothing period for %D signal line (commonly 3)
        
        Returns:
            Indicator: Stochastic indicator (returns [%K, %D])
        
        Raises:
            ValueError: If parameters are invalid
        
        Note:
            Requires candle input (High, Low, Close)
        """
    @staticmethod
    def mae(period:builtins.int) -> Indicator:
        r"""
        Create a Mean Absolute Error (MAE) indicator.
        
        MAE measures average prediction error magnitude, useful for model validation.
        
        Math:
            MAE = (Σ|Actual_i - Predicted_i|) / n
            where n is the period
        
        Args:
            period: Window for error calculation
        
        Returns:
            Indicator: MAE indicator instance
        
        Raises:
            ValueError: If period is invalid
        """
    @staticmethod
    def sd(period:builtins.int) -> Indicator:
        r"""
        Create a Standard Deviation (SD) indicator.
        
        SD measures price volatility and dispersion.
        
        Math:
            σ = sqrt(Σ(x_i - μ)² / n)
            where μ is the mean, n is the period
        
        Args:
            period: Number of periods for calculation (commonly 20)
        
        Returns:
            Indicator: Standard Deviation indicator instance
        
        Raises:
            ValueError: If period is invalid
        """
    @staticmethod
    def kc(period:builtins.int, multiplier:builtins.float) -> Indicator:
        r"""
        Create a Keltner Channel (KC) indicator.
        
        KC uses EMA and ATR to create volatility-based channels.
        
        Math:
            Middle Line = EMA(Close, period)
            Upper Band = Middle Line + (multiplier × ATR)
            Lower Band = Middle Line - (multiplier × ATR)
        
        Args:
            period: Period for EMA and ATR (commonly 20)
            multiplier: ATR multiplier for bands (commonly 2.0)
        
        Returns:
            Indicator: Keltner Channel indicator (returns [Upper, Middle, Lower])
        
        Raises:
            ValueError: If parameters are invalid
        
        Note:
            Requires candle input (High, Low, Close)
        """
    @staticmethod
    def obv() -> Indicator:
        r"""
        Create an On-Balance Volume (OBV) indicator.
        
        OBV measures cumulative buying/selling pressure using volume.
        
        Math:
            If Close > Close_prev: OBV = OBV_prev + Volume
            If Close < Close_prev: OBV = OBV_prev - Volume
            If Close = Close_prev: OBV = OBV_prev
        
        Returns:
            Indicator: OBV indicator instance
        
        Note:
            Requires candle input with volume data
        """
    @staticmethod
    def ao(short_period:builtins.int, long_period:builtins.int) -> Indicator:
        r"""
        Create an Awesome Oscillator (AO) indicator.
        
        AO measures momentum using the difference between two SMAs.
        
        Math:
            Median Price = (High + Low) / 2
            AO = SMA(Median Price, short_period) - SMA(Median Price, long_period)
        
        Args:
            short_period: Period for short SMA (commonly 5)
            long_period: Period for long SMA (commonly 34)
        
        Returns:
            Indicator: Awesome Oscillator indicator instance
        
        Raises:
            ValueError: If parameters are invalid or short >= long
        
        Note:
            Requires candle input (High, Low)
        """
    @staticmethod
    def williams_r(period:builtins.int) -> Indicator:
        r"""
        Create a Williams %R indicator.
        
        Williams %R measures overbought/oversold conditions, oscillating between 0 and -100.
        
        Math:
            %R = ((Highest High - Close) / (Highest High - Lowest Low)) × -100
            where High/Low are over the lookback period
            Overbought: %R > -20, Oversold: %R < -80
        
        Args:
            period: Lookback period (commonly 14)
        
        Returns:
            Indicator: Williams %R indicator instance
        
        Raises:
            ValueError: If period is invalid
        
        Note:
            Requires candle input (High, Low, Close)
        """
    @staticmethod
    def smma(period:builtins.int) -> Indicator:
        r"""
        Create a Smoothed Moving Average (SMMA) indicator.
        
        SMMA is similar to EMA but with different smoothing, used in Alligator indicator.
        
        Math:
            SMMA_t = (SMMA_(t-1) × (n-1) + Price_t) / n
            where n is the period
        
        Args:
            period: Number of periods for smoothing (commonly 14)
        
        Returns:
            Indicator: SMMA indicator instance
        
        Raises:
            ValueError: If period is invalid
        """
    @staticmethod
    def alligator(jaw_period:builtins.int, jaw_shift:builtins.int, teeth_period:builtins.int, teeth_shift:builtins.int, lips_period:builtins.int, lips_shift:builtins.int) -> Indicator:
        r"""
        Create an Alligator indicator.
        
        Alligator uses three smoothed moving averages (Jaw, Teeth, Lips) for trend analysis.
        
        Math:
            Jaw (Blue Line) = SMMA(Median Price, jaw_period), shifted forward by jaw_shift
            Teeth (Red Line) = SMMA(Median Price, teeth_period), shifted forward by teeth_shift
            Lips (Green Line) = SMMA(Median Price, lips_period), shifted forward by lips_shift
            where Median Price = (High + Low) / 2
        
        Args:
            jaw_period: Period for Jaw line (commonly 13)
            jaw_shift: Forward shift for Jaw (commonly 8)
            teeth_period: Period for Teeth line (commonly 8)
            teeth_shift: Forward shift for Teeth (commonly 5)
            lips_period: Period for Lips line (commonly 5)
            lips_shift: Forward shift for Lips (commonly 3)
        
        Returns:
            Indicator: Alligator indicator (returns [Jaw, Teeth, Lips])
        
        Raises:
            ValueError: If parameters are invalid
        
        Note:
            Requires candle input
        """
    def to_json(self) -> builtins.str:
        r"""
        Serialize the indicator to a JSON string.
        
        Returns:
            str: JSON representation of the indicator with type and parameters
        
        Raises:
            ValueError: If serialization fails
        
        Example:
            >>> rsi = Indicator.rsi(14)
            >>> json_str = rsi.to_json()
            >>> print(json_str)  # {"type":"Rsi","period":14}
        """
    def period(self) -> builtins.int:
        r"""
        Get the warmup period for the indicator.
        
        Returns the number of data points (candles or prices) required before the indicator
        produces accurate results. During the warmup period, outputs may be unreliable or
        based on incomplete data.
        
        Returns:
            int: Number of periods needed for warmup
        
        Example:
            >>> rsi = Indicator.rsi(14)
            >>> print(rsi.period())  # 14
            >>> sma = Indicator.sma(20)
            >>> print(sma.period())  # 20
        """
    def reset(self) -> None:
        r"""
        Reset the indicator to its initial state.
        
        This clears any accumulated state and prepares the indicator for fresh calculations.
        Useful when you want to reuse an indicator instance with new data.
        
        Example:
            >>> rsi = Indicator.rsi(14)
            >>> rsi.next(100.0)
            >>> rsi.next(101.0)
            >>> rsi.reset()  # Clear all accumulated state
            >>> rsi.next(100.0)  # Start fresh calculations
        """
    def next(self, input:builtins.float) -> typing.Any:
        r"""
        Process a single price value through the indicator.
        
        Args:
            input: Price value to process
        
        Returns:
            float | list[float]: Indicator output (single value or array)
        
        Raises:
            ValueError: If the indicator requires candle input or processing fails
        
        Note:
            Some indicators (like Stochastic, OBV) require candle input and will raise an error.
            Use next_candle() for those indicators.
        
        Example:
            >>> rsi = Indicator.rsi(14)
            >>> result = rsi.next(100.5)
        """
    def next_batched(self, input:typing.Sequence[builtins.float]) -> builtins.list[typing.Any]:
        r"""
        Process multiple price values through the indicator.
        
        Args:
            input: List of price values to process sequentially
        
        Returns:
            list: List of indicator outputs (each can be float or list[float])
        
        Raises:
            ValueError: If the indicator requires candle input or processing fails
        
        Note:
            This processes values sequentially, maintaining indicator state between calls.
        
        Example:
            >>> sma = Indicator.sma(3)
            >>> results = sma.next_batched([100.0, 101.0, 102.0, 103.0])
        """
    def next_candle(self, candle:Candle) -> typing.Any:
        r"""
        Process a single candle through the indicator.
        
        Args:
            candle: Candle object with OHLCV data
        
        Returns:
            float | list[float]: Indicator output (single value or array)
        
        Raises:
            ValueError: If processing fails
        
        Example:
            >>> atr = Indicator.atr(14)
            >>> candle = Candle.new(100.0, 101.0, 99.0, 100.0, 100.5, 1000.0)
            >>> result = atr.next_candle(candle)
        """
    def next_candles(self, candles:typing.Sequence[Candle]) -> builtins.list[typing.Any]:
        r"""
        Process multiple candles through the indicator.
        
        Args:
            candles: List of Candle objects to process sequentially
        
        Returns:
            list: List of indicator outputs (each can be float or list[float])
        
        Raises:
            ValueError: If processing fails
        
        Note:
            This processes candles sequentially, maintaining indicator state between calls.
        
        Example:
            >>> bb = Indicator.bb(20, 2.0)
            >>> candles = [Candle.price(100.0), Candle.price(101.0), Candle.price(102.0)]
            >>> results = bb.next_candles(candles)
        """
    def update(self, candle:builtins.str) -> None:
        r"""
        Update the indicator state with a new candle (internal use).
        
        This method is intended for internal use to pre-warm indicators by processing
        candles until the indicator has accumulated enough data (at least `period()` candles).
        It processes a candle but discards the output, only updating the internal state.
        
        Most users should use `next_candle()` or `next_candles()` instead, which return
        the computed indicator values. This method is primarily used by framework internals
        to prepare indicators before they produce meaningful results.
        
        Args:
            candle: JSON string representation of a candle to process
        
        Raises:
            ValueError: If the JSON is invalid or processing fails
        
        Note:
            This method updates the indicator's internal state but doesn't return any output.
            Call this method at least `period()` times before expecting accurate results
            from `next()` or `next_candle()`.
        
        Example:
            >>> rsi = Indicator.rsi(14)
            >>> # Warm up the indicator with historical data
            >>> for candle_json in historical_candles[:14]:
            ...     rsi.update(candle_json)
            >>> # Now the indicator is ready for accurate results
            >>> result = rsi.next_candle(current_candle)
        """
    def __str__(self) -> builtins.str:
        r"""
        Return a JSON string representation of the indicator.
        
        This is equivalent to to_json() and is used by Python's str() function.
        
        Returns:
            str: JSON representation of the indicator
        
        Example:
            >>> rsi = Indicator.rsi(14)
            >>> print(str(rsi))  # {"type":"Rsi","period":14}
        """
    def __repr__(self) -> builtins.str:
        r"""
        Return a developer-friendly string representation of the indicator.
        
        This provides a more readable format than __str__ and is used by Python's repr() function.
        
        Returns:
            str: Human-readable representation of the indicator
        
        Example:
            >>> rsi = Indicator.rsi(14)
            >>> print(repr(rsi))  # Indicator(Rsi { period: 14 })
        """

